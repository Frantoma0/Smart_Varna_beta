<!DOCTYPE html>
<html lang="bg">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Външни библиотеки -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libheif-js@1.17.1/libheif.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Leaflet Map Library -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        /* --- ОСНОВНИ СТИЛОВЕ (С ПОДОБРЕНИЯ) --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f9;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #chat-container {
            width: 100%;
            max-width: 600px;
            height: 90vh;
            max-height: 800px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 10;
        }

        #chat-log {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* UI ПОДОБРЕНИЕ: Анимация при появяване на съобщенията */
        .chat-message {
            padding: 10px 15px;
            border-radius: 20px;
            max-width: 80%;
            line-height: 1.5;
            word-wrap: break-word;
            white-space: pre-wrap;
            transform: scale(0.95);
            opacity: 0;
            animation: message-enter 0.3s ease-out forwards;
        }

        @keyframes message-enter {
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .bot-message {
            background-color: #f1f0f0;
            color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }

        .user-message {
            background-color: #007bff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 5px;
            padding: 5px;
        }

        .user-message img {
            max-width: 100%;
            border-radius: 15px;
            display: block;
        }

        .processing-message-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .loading-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #9eaab6;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .loading-indicator span:nth-child(1) {
            animation-delay: -0.32s;
        }

        .loading-indicator span:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1.0);
            }
        }

        /* UI ПОДОБРЕНИЕ: По-добър фокус и визия на полето за въвеждане */
        #input-area {
            border-top: 1px solid #e0e0e0;
            padding: 12px 15px;
            background-color: #ffffff;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: box-shadow 0.2s;
        }

        #chat-input {
            flex-grow: 1;
            border: none;
            background: transparent;
            padding: 10px 5px;
            font-size: 16px;
        }

        #chat-input:focus {
            outline: none;
        }

        #chat-input:focus-within {
            box-shadow: 0 -2px 10px rgba(0, 123, 255, 0.1);
        }

        /* UI ПОДОБРЕНИЕ: Микро-интеракции при бутоните */
        .input-button {
            border: none;
            background: none;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            transition: transform 0.2s, color 0.2s;
        }

        .input-button:hover {
            transform: scale(1.1);
            color: #007bff;
        }

        .input-button img,
        .input-button svg {
            width: 24px;
            height: 24px;
        }

        #send-btn {
            color: white;
            background-color: #007bff;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            flex-shrink: 0;
        }

        #send-btn:hover {
            color: white;
            background-color: #0056b3;
        }

        #file-input {
            display: none;
        }

        /* UX ПОДОБРЕНИЕ: Стил за "Бързи отговори" */
        .quick-replies {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .quick-reply-btn {
            background-color: transparent;
            border: 1px solid #007bff;
            color: #007bff;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: background-color 0.2s, color 0.2s;
        }

        .quick-reply-btn:hover {
            background-color: #007bff;
            color: white;
        }

        /* UX ПОДОБРЕНИЕ: Анимация за подсказка */
        @keyframes pulse-highlight {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
            }

            70% {
                transform: scale(1.1);
                box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
            }
        }

        .highlight-action {
            animation: pulse-highlight 1.5s infinite;
            border-radius: 50%;
        }

        /* UI ПОДОБРЕНИЕ: По-добри бутони за действия */
        .location-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 8px;
            font-weight: bold;
            border: 1px solid #007bff;
            transition: transform 0.2s, background-color 0.2s;
        }

        .location-button:hover {
            transform: translateY(-2px);
        }

        .location-button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .skip-button {
            background-color: #6c757d;
            border-color: #6c757d;
            margin-left: 5px;
        }

        .skip-button:hover {
            background-color: #5a6268;
        }

        .confirm-button {
            background-color: #28a745;
            border-color: #28a745;
            margin-right: 10px;
        }

        .confirm-button:hover {
            background-color: #218838;
        }

        .cancel-button {
            background-color: #dc3545;
            border-color: #dc3545;
        }

        .cancel-button:hover {
            background-color: #c82333;
        }

        .edit-button {
            background-color: #ffc107;
            border-color: #ffc107;
            color: #212529;
            margin-left: 5px;
        }

        .edit-button:hover {
            background-color: #e0a800;
        }

        .media-container {
            position: relative;
            overflow: hidden;
            border-radius: 15px;
            line-height: 0;
            max-width: 300px;
        }

        .uploaded-photo {
            transition: opacity 0.5s ease-in-out;
            width: 100%;
        }

        .uploaded-photo.fade-out {
            opacity: 0;
        }

        .map-inline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1;
            border-radius: 15px;
        }

        .map-inline.fade-in {
            opacity: 1;
        }

        .map-inline.fade-out {
            opacity: 0;
        }

        #mic-btn.listening {
            color: #dc3545;
            animation: pulse-mic 1.5s infinite;
        }

        @keyframes pulse-mic {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
            }
        }

        /* --- СТИЛОВЕ ЗА АНИМАЦИЯ НА ИЗПРАЩАНЕ (без промяна) --- */
        .signal-card-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        .signal-card-overlay.visible {
            opacity: 1;
        }

        .card-flipper {
            width: 90%;
            max-width: 480px;
            height: 80%;
            max-height: 640px;
            perspective: 1500px;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.8s;
            transform-style: preserve-3d;
        }

        .card-inner.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .card-face-front {
            /* Лицевата страна */
        }

        .card-face-back {
            transform: rotateY(180deg);
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .card-description {
            padding: 15px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            flex-shrink: 0;
        }

        .card-media-container {
            flex-grow: 1;
            position: relative;
            background-color: #e0e0e0;
        }

        .card-photo,
        .card-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.5s ease-in-out;
        }

        .card-photo.fade-out {
            opacity: 0;
        }

        .card-map {
            opacity: 0;
        }

        .card-map.fade-in {
            opacity: 1;
        }

        .card-institution-icon {
            width: 120px;
            height: 120px;
        }

        .card-institution-name {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            text-align: center;
            padding: 0 20px;
        }
    </style>
</head>

<body>

    <div id="chat-container">
        <div id="chat-log"></div>
        <div id="input-area">
            <label for="file-input" id="file-input-label" class="input-button">
                <svg fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd"
                        d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z"
                        clip-rule="evenodd"></path>
                </svg>
            </label>
            <button id="mic-btn" class="input-button">
                <img src="images/mic.png" alt="Микрофон">
            </button>
            <input type="text" id="chat-input" placeholder="Напишете съобщение...">
            <button id="send-btn" class="input-button">
                <svg fill="currentColor" viewBox="0 0 20 20">
                    <path
                        d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z">
                    </path>
                </svg>
            </button>
            <input type="file" id="file-input" accept="image/*,.heic,.heif">
        </div>
    </div>

    <script>
        // ===================================================================
        // КОНФИГУРАЦИЯ - ПОПЪЛНЕТЕ ВСИЧКИ КЛЮЧОВЕ ТУК
        // ===================================================================
        // Remove import of keys.js and any secret variables
        // Remove: import { OPENAI_API_KEY, OPENCAGE_API_KEY, SUPABASE_URL, SUPABASE_ANON_KEY } from './keys.js';
        // Remove: const supabaseClient = supabase.createClient(...);
        // For all OpenAI, OpenCage, and Supabase operations, replace with fetches to backend endpoints
        // Example for OpenAI:
        //   fetch('/api/analyze-image', { ... })
        // Example for OpenCage:
        //   fetch(`/api/get-address?lat=${lat}&lng=${lng}`)
        // Example for Supabase:
        //   fetch('/api/submit-signal', { method: 'POST', body: JSON.stringify(signalData), headers: { 'Content-Type': 'application/json' } })
        //   fetch(`/api/check-status?tracking_code=${trackingCode}`)
        // All logic and UI remain, but all sensitive operations are now backend calls.

        const dataCategoriesJSON = `{"Данъци и такси": { "institution": "Община Варна" }, "Управление на общинска собственост": { "institution": "Община Варна" }, "Зониране и развитие": { "institution": "Община Варна" }, "Градско планиране": { "institution": "Община Варна" }, "Поддръжка на паркове": { "institution": "Община Варна" }, "Улични пейки и обзавеждане": { "institution": "Община Варна" }, "Проблеми с чистотата": { "institution": "Община Варна" }, "Нарушения при паркиране": { "institution": "Община Варна" }, "Дървета и растителност": { "institution": "Община Варна" }, "Местни данъци": { "institution": "Район Одесос" }, "Районни пътища": { "institution": "Район Одесос" }, "Поддръжка на тротоари": { "institution": "Район Одесос" }, "Улични знаци и маркировки": { "institution": "Район Одесос" }, "Комунални услуги в квартала": { "institution": "Район Одесос" }, "Местни данъци (Приморски)": { "institution": "Район Приморски" }, "Районни пътища (Приморски)": { "institution": "Район Приморски" }, "Поддръжка на тротоари (Приморски)": { "institution": "Район Приморски" }, "Улични знаци и маркировки (Приморски)": { "institution": "Район Приморски" }, "Комунални услуги в квартала (Приморски)": { "institution": "Район Приморски" }, "Местни данъци (Младост)": { "institution": "Район Младост" }, "Районни пътища (Младост)": { "institution": "Район Младост" }, "Поддръжка на тротоари (Младост)": { "institution": "Район Младост" }, "Улични знаци и маркировки (Младост)": { "institution": "Район Младост" }, "Комунални услуги в квартала (Младост)": { "institution": "Район Младост" }, "Местни данъци (Аспарухово)": { "institution": "Район Аспарухово" }, "Районни пътища (Аспарухово)": { "institution": "Район Аспарухово" }, "Поддръжка на тротоари (Аспарухово)": { "institution": "Район Аспарухово" }, "Улични знаци и маркировки (Аспарухово)": { "institution": "Район Аспарухово" }, "Комунални услуги в квартала (Аспарухово)": { "institution": "Район Аспарухово" }, "Местни данъци (Владислав Варненчик)": { "institution": "Район Владислав Варненчик" }, "Районни пътища (Владислав Варненчик)": { "institution": "Район Владислав Варненчик" }, "Поддръжка на тротоари (Владислав Варненчик)": { "institution": "Район Владислав Варненчик" }, "Улични знаци и маркировки (Владислав Варненчик)": { "institution": "Район Владислав Варненчик" }, "Комунални услуги в квартала (Владислав Варненчик)": { "institution": "Район Владислав Варненчик" }, "Нарушения при паркиране (МВР)": { "institution": "Областна дирекция на МВР - Варна" }, "Опасностно шофиране": { "institution": "Областна дирекция на МВР - Варна" }, "Превишена скорост": { "institution": "Областна дирекция на МВР - Варна" }, "Пътни произшествия": { "institution": "Областна дирекция на МВР - Варна" }, "Шумни превозни средства": { "institution": "Областна дирекция на МВР - Варна" }, "Нелегални събирания": { "institution": "Областна дирекция на МВР - Варна" }, "Графити и вандализъм": { "institution": "Областна дирекция на МВР - Варна" }, "Обществен ред": { "institution": "Областна дирекция на МВР - Варна" }, "Престъпления": { "institution": "Районна прокуратура - Варна" }, "Корупция": { "institution": "Районна прокуратура - Варна" }, "Имотни престъпления": { "institution": "Районна прокуратура - Варна" }, "Нарушения на закона": { "institution": "Районна прокуратура - Варна" }, "Граждански спорове": { "institution": "Окръжен съд - Варна" }, "Търговски дела": { "institution": "Окръжен съд - Варна" }, "Административни спорове": { "institution": "Окръжен съд - Варна" }, "Наказателни дела": { "institution": "Районен съд - Варна" }, "Семейни спорове": { "institution": "Районен съд - Варна" }, "Малки търговски спорове": { "institution": "Районен съд - Варна" }, "Данъчни въпроси": { "institution": "ТД на НАП Варна" }, "Такси и мита": { "institution": "ТД на НАП Варна" }, "Финансови нарушения": { "institution": "ТД на НАП Варна" }, "Пенсионни въпроси": { "institution": "НОИ - Варна" }, "Осигуровки": { "institution": "НОИ - Варна" }, "Инвалидност": { "institution": "НОИ - Варна" }, "Потребителски права": { "institution": "КЗП - Варна" }, "Нечестни търговски практики": { "institution": "КЗП - Варна" }, "Качество на стоки и услуги": { "institution": "КЗП - Варна" }, "Трудови спорове": { "institution": "Инспекция по труда" }, "Нередовни заплати": { "institution": "Инспекция по труда" }, "Условия на труд": { "institution": "Инспекция по труда" }, "Здравни стандарти": { "institution": "РЗИ - Варна" }, "Хигиена": { "institution": "РЗИ - Варна" }, "Епидемиологичен контрол": { "institution": "РЗИ - Варна" }, "Безопасност на храните": { "institution": "РЗИ - Варна" }, "Замърсяване на въздуха": { "institution": "РИОСВ - Варна" }, "Незаконно изхвърляне на отпадъци": { "institution": "РИОСВ - Варна" }, "Замърсяване на водите": { "institution": "РИОСВ - Варна" }, "Шумово замърсяване": { "institution": "РИОСВ - Варна" }, "Водоснабдяване": { "institution": "ВиК Варна ООД" }, "Канализационни проблеми": { "institution": "ВиК Варна ООД" }, "Течове от тръби": { "institution": "ВиК Варна ООД" }, "Запушване на канали": { "institution": "ВиК Варна ООД" }, "Обществен транспорт": { "institution": "Градски транспорт ЕАД" }, "Автобусни спирки": { "institution": "Градски транспорт ЕАД" }, "Разписания": { "institution": "Градски транспорт ЕАД" }, "Качество на услугите": { "institution": "Градски транспорт ЕАД" }, "Светофари": { "institution": "ОП ТАСРУД" }, "Пътна маркировка": { "institution": "ОП ТАСРУД" }, "Улични знаци": { "institution": "ОП ТАСРУД" }, "Регулиране на трафика": { "institution": "ОП ТАСРУД" }, "Природни бедствия": { "institution": "Гражданска защита - Областно управление" }, "Аварийни ситуации": { "institution": "Гражданска защита - Областно управление" }, "Евакуации": { "institution": "Гражданска защита - Областно управление" }, "Пожари (Първа РСПБЗН)": { "institution": "Първа РСПБЗН – Варна" }, "Аварийни сигнали (Първа РСПБЗН)": { "institution": "Първа РСПБЗН – Варна" }, "Пожарна безопасност (Първа РСПБЗН)": { "institution": "Първа РСПБЗН – Варна" }, "Пожари (Втора РСПБЗН)": { "institution": "Втора РСПБЗН – Варна" }, "Аварийни сигнали (Втора РСПБЗН)": { "institution": "Втора РСПБЗН – Варна" }, "Пожарна безопасност (Втора РСПБЗН)": { "institution": "Втора РСПБЗН – Варна" }, "Дупки по пътя": { "institution": "Агенция Пътна инфраструктура" }, "Повредени пътни настилки": { "institution": "Агенция Пътна инфраструктура" }, "Качество на пътищата": { "institution": "Агенция Пътна инфраструктура" }, "Пътна безопасност": { "institution": "Агенция Пътна инфраструктура" } }`;
        const OPENAI_VISION_SYSTEM_PROMPT = `РОЛЯ И КОНТЕКСТ: Ти си високоспециализиран AI асистент за Община Варна. Твоята единствена задача е да анализираш изображения, подадени от граждани, и да идентифицираш ЕДИН-ЕДИНСТВЕН, най-съществен комунален проблем. Твоят отговор ще бъде използван за автоматично попълване на поле "описание" в система за граждански сигнали, затова трябва да бъде максимално точен, кратък и напълно лишен от допълнителен текст. ПРОЦЕС НА АНАЛИЗ (Следвай тези стъпки в мислите си): Първична инспекция: Огледай цялото изображение, за да разбереш общата сцена (улица, парк, тротоар, междублоково пространство). Идентификация на нередности: Активно търси проблеми, попадащи в категориите по-долу. Приоритизация: Ако има повече от една нередност, определи коя е най-значимата или най-спешната. Фокусирай се само върху нея. Формулиране на отговора: Създай финалния отговор, като стриктно спазваш правилата за формат. КАТЕГОРИИ НА ПРОБЛЕМИ ЗА АНАЛИЗ: Инфраструктура: Дупки по платното, счупени плочки, отворени или повредени шахти, паднали/счупени пътни знаци, повредени колчета. Чистота и отпадъци: Преливащи контейнери, боклук извън контейнерите, незаконни сметища, непочистени площи. Поддръжка на зелени площи: Неокосена трева, паднали или опасно надвиснали клони/дървета, избуяла растителност, която пречи на преминаването. Градски инвентар и вандализъм: Счупени пейки, повредени спирки на градски транспорт, графити върху обществени сгради и съоръжения. Неправилно паркиране: Автомобили, паркирани на тротоари, пешеходни пътеки, зелени площи или рампи за инвалиди. ЗАДЪЛЖИТЕЛНИ ПРАВИЛА ЗА ФОРМАТА НА ОТГОВОРА: ЕДИНСТВЕНО ОПИСАНИЕ: Върни само и единствевено текстовото описание на проблема. ДЪЛЖИНА: Отговорът трябва да е между 3 и 7 думи. СЪДЪРЖАНИЕ: Описанието трябва ясно да посочва КАКЪВ е проблемът и КЪДЕ се намира спрямо друг обект. БЕЗ ДОПЪЛНИТЕЛЕН ТЕКСТ: Отговорът НЕ трябва да съдържа обръщения, обяснения, коментари или какъвто и да е текст извън описанието. БЕЗ ПРЕПИНАТЕЛНИ ЗНАЦИ: Не използвай препинателни знаци в края на изречението. СПРАВЯНЕ СЪС СПЕЦИФИЧНИ СЛУЧАИ: Ако няма явен проблем: Върни точния текст: Не е установена нередност, моля опишете проблема. Ако изображението е неясно или тъмно: Върни точния текст: Неясна снимка, моля опишете проблема. ПРИМЕРИ: ДОБРИ ПРИМЕРИ (Това е, което очаквам): Дупка по пътното платно. Неокосена трева в междублоково пространство. Преливащ контейнер за смет. Счупена пейка в градинка. Опасен клон надвиснал над тротоар. Неправилно паркиран автомобил на тротоар. Паднал пътен знак на кръстовище. Висока растителност пречи на видимостта. ЛОШИ ПРИМЕРИ (Това НЕ трябва да правиш): Грешно: Проблем: Неокосена трева. (Съдържа "Проблем:" и точка). Грешно: На снимката се вижда висока трева. (Излишно описателно изречение). Грешно: Трева (Твърде кратко, липсва контекст)`;
        const OPENAI_INSTITUTION_PROMPT = `РОЛЯ И КОНТЕКСТ: Ти си AI рутер за разпределение на сигнали в Община Варна. Твоята единствена задача е да анализираш кратко описание на проблем и да определиш коя институция е отговорна за него. ИНСТРУКЦИИ: 1. Ще получиш описание на проблем. 2. Ще получиш JSON обект, в който ключовете са типове проблеми, а стойностите съдържат името на отговорната институция. 3. Съпостави описанието на проблема с най-подходящия тип проблем от JSON-а. 4. Върни САМО И ЕДИНСТВЕНО името на институцията ("institution") като чист текст. ЗАДЪЛЖИТЕЛНИ ПРАВИЛА ЗА ФОРМАТА НА ОТГОВОРА: - БЕЗ ДОПЪЛНИТЕЛЕН ТЕКСТ: Отговорът НЕ трябва да съдържа обръщения, коментари, JSON форматиране или какъвто и да е текст извън името на институцията. - Ако не можеш да определиш институция, върни "Община Варна". ПРИМЕРИ: - При подадено описание "Дупка по пътя", трябва да върнеш "Агенция Пътна инфраструктура". - При подадено описание "Преливащ контейнер за смет", трябва да върнеш "Община Варна". - При подадено описание "Неправилно паркиран автомобил на тротоар", трябва да върнеш "Община Варна". JSON ДАННИ С ИНСТИТУЦИИ: ${dataCategoriesJSON}`;
        const OPENAI_INTENT_PROMPT = `Ти си AI за класифициране на намерения. Анализирай последното съобщение на потребителя и определи неговото намерение. Възможните намерения са: 'submit_signal', 'check_status', 'general_chat'. Ако потребителят описва проблем (напр. "има дупка", "боклукът е разхвърлян"), намерението е 'submit_signal'. Ако пита за статус или дава код за проследяване (напр. "провери SV-12345", "какъв е статусът"), намерението е 'check_status'. Във всички останали случаи е 'general_chat'. Извлечи и проследяващия код, ако има такъв. Върни резултата САМО като JSON обект. Пример: {"intent": "check_status", "tracking_code": "SV-12345"}.`;
        const OPENAI_EXTRACTION_PROMPT = `Ти си AI за извличане на информация. Твоята задача е да анализираш последното съобщение на потребителя в разговор и да извлечеш описание на проблем и/или адрес. Потребителят подава сигнал за нередност в град Варна. Върни резултата САМО като JSON обект с ключове "description" и "address". Ако дадена информация липсва, стойността трябва да е null. Описанието трябва да е кратко и ясно. Пример: User: "има паднало дърво на булевард Сливница 23" -> {"description": "паднало дърво", "address": "булевард Сливница 23, Варна"}. User: "боклуците пред нас не са изхвърлени" -> {"description": "неизхвърлени боклуци", "address": null}.`;
        const OPENAI_CONVERSATION_SYSTEM_PROMPT = `Ти си "Смарти", приятелски и леко неформален дигитален асистент на SmartVarna. Твоята главна и единствена цел е да накараш потребителя да започне процеса по подаване на сигнал. НАЧИНИ ЗА ПОДАВАНЕ НА СИГНАЛ: 1. Чрез прикачане на снимка. 2. Чрез изписване на точната фраза "сигнал без снимка". ТВОЯТА ЛИЧНОСТ И ПОВЕДЕНИЕ: - Говори кратко, ясно и директно (1-2 изречения). Бъди услужлив и позитивен. Използвай емоджита. 😊 - Не се представяй отново. Разговорът има памет. - **КЛЮЧОВО ПРАВИЛО:** Когато потребителят те пита КАК да подаде сигнал, или дали може да подаде сигнал без снимка, или директно описва проблем, твоята задача е да го насочиш към един от двата официални начина. Примери: User: Мога ли да подам сигнал без снимка? Smarty: Разбира се! Просто напишете 'сигнал без снимка' в чата, за да започнем. 👍 User: Има паднало дърво до мен. Smarty: Разбирам, нека регистрираме сигнала. Моля, прикачете снимка или напишете 'сигнал без снимка', за да продължим. User: Как си? Smarty: Супер съм, благодаря! Готов съм да помогна. Имате ли сигнал за подаване? Може да прикачите снимка или да напишете 'сигнал без снимка'.`;

        // ===================================================================
        // ОСНОВНА ЛОГИКА НА ЧАТБОТА
        // ===================================================================

        const chatLog = document.getElementById('chat-log');
        const fileInput = document.getElementById('file-input');
        const fileInputLabel = document.getElementById('file-input-label');
        const chatInput = document.getElementById('chat-input');
        const sendBtn = document.getElementById('send-btn');
        const micBtn = document.getElementById('mic-btn');

        let conversationState = 'idle';
        let tempSignalData = {};
        let conversationHistory = [];
        let recognition;

        // UX ПОДОБРЕНИЕ: Променено първоначално съобщение с бързи отговори
        document.addEventListener('DOMContentLoaded', () => {
            const initialMessage = `Здравейте! Аз съм Смарти. 😊 Как мога да ви помогна днес?
    <div class="quick-replies">
        <button class="quick-reply-btn" data-action="start_signal_photo">📷 Подай сигнал със снимка</button>
        <button class="quick-reply-btn" data-action="start_signal_no_photo">✍️ Подай сигнал без снимка</button>
        <button class="quick-reply-btn" data-action="check_status">#️⃣ Провери статус</button>
    </div>`;
            addBotMessage(initialMessage, true);
            setupSpeechRecognition();
        });

        fileInput.addEventListener('change', handleFileSelect);
        sendBtn.addEventListener('click', handleTextInput);
        chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleTextInput(); });
        chatLog.addEventListener('click', handleChatButtonClick); // Този handler вече ще управлява и бързите отговори
        micBtn.addEventListener('click', toggleSpeechRecognition);

        function addMessage(content, type, isHtml = false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message', type);
            if (isHtml) messageDiv.innerHTML = content;
            else messageDiv.textContent = content;
            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
            return messageDiv;
        }
        function addBotMessage(text, isHtml = false) { return addMessage(text, 'bot-message', isHtml); }
        function addUserMessage(content, isImage = false) {
            if (isImage) {
                const msgElement = addMessage('', 'user-message', true);
                msgElement.innerHTML = `<div class="media-container"><img src="${content}" alt="Прикачена снимка" class="uploaded-photo"></div>`;
                return msgElement.querySelector('.media-container');
            }
            return addMessage(content, 'user-message');
        }
        function updateProcessingMessage(text) {
            let processingMsg = document.getElementById('processing-message');
            if (!processingMsg) {
                const messageDiv = document.createElement('div');
                messageDiv.id = 'processing-message';
                messageDiv.classList.add('chat-message', 'bot-message');
                messageDiv.innerHTML = `<div class="processing-message-content">
            <span class="message-text">${text}</span>
            <div class="loading-indicator"><span></span><span></span><span></span></div>
        </div>`;
                chatLog.appendChild(messageDiv);
            } else {
                processingMsg.querySelector('.message-text').textContent = text;
            }
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        function removeProcessingMessage() { document.getElementById('processing-message')?.remove(); }
        function toggleInput(enabled, placeholder = 'Напишете съобщение...') {
            chatInput.disabled = !enabled;
            sendBtn.disabled = !enabled;
            fileInput.disabled = !enabled;
            micBtn.disabled = !enabled;
            chatInput.placeholder = enabled ? placeholder : 'Смарти мисли...';
        }

        async function handleTextInput() {
            const text = chatInput.value.trim();
            if (text === '' || conversationState.includes('processing')) return;
            addUserMessage(text);
            chatInput.value = '';
            conversationHistory.push({ role: 'user', content: text });

            // UX ПОДОБРЕНИЕ: Специален случай за "сигнал без снимка"
            if (text.toLowerCase() === 'сигнал без снимка' && conversationState === 'idle') {
                startSignalFlow(false);
                return;
            }

            switch (conversationState) {
                case 'awaiting_tracking_code':
                    handleSignalCheck(text);
                    break;
                case 'awaiting_manual_description':
                case 'awaiting_address':
                    await processTextForSignalData(text);
                    break;
                case 'awaiting_email':
                    if (isValidEmail(text) || ['пропусни', 'не'].includes(text.toLowerCase())) {
                        tempSignalData.email = text.toLowerCase();
                        askForFinalConfirmation(); // UX: Директно към финално потвърждение
                    } else {
                        addBotMessage("Това не изглежда като валиден имейл. Моля, въведете го отново или натиснете бутона 'Пропусни'.");
                    }
                    break;
                case 'awaiting_confirmation':
                    addBotMessage("Моля, използвайте бутоните 'Потвърди', 'Промени' или 'Отмени', за да продължите.");
                    break;
                default: // idle
                    determineUserIntent(text);
                    break;
            }
        }

        async function determineUserIntent(text) {
            toggleInput(false);
            updateProcessingMessage("Анализирам...");
            try {
                const intentData = await getIntentFromText(text);
                removeProcessingMessage();

                if (intentData.intent === 'check_status') {
                    handleSignalCheck(intentData.tracking_code);
                } else if (intentData.intent === 'submit_signal') {
                    startSignalFlow(false, text); // Започваме процеса без снимка, но с вече подаден текст
                } else {
                    const botResponse = await getConversationalResponse();
                    addBotMessage(botResponse);
                    conversationHistory.push({ role: 'assistant', content: botResponse });
                    toggleInput(true);
                }
            } catch (error) {
                removeProcessingMessage();
                addBotMessage(`Упс, възникна грешка при анализа: ${error.message} 🧐`);
                toggleInput(true);
            }
        }

        async function handleSignalCheck(trackingCode) {
            if (!trackingCode) {
                conversationState = 'awaiting_tracking_code';
                addBotMessage("Разбира се, моля въведете кода за проследяване (напр. SV-XXXXXX).");
                toggleInput(true, "Въведете код...");
                return;
            }

            toggleInput(false);
            updateProcessingMessage(`Проверявам статус за ${trackingCode}... ⏳`);

            try {
                const { data, error } = await getSupabaseClientOrAlert()
                    .from('signal')
                    .select(`description, date_created, institution, status ( description, date_changed )`)
                    .eq('tracking_code', trackingCode.toUpperCase())
                    .single();

                removeProcessingMessage();

                if (error || !data) {
                    addBotMessage(`Не намирам сигнал с код **${trackingCode}**. Моля, проверете го и опитайте отново.`);
                } else {
                    const formattedDate = new Date(data.status.date_changed).toLocaleString('bg-BG');
                    let statusMessage = `Ето информацията за сигнал **${trackingCode}**:
- **Проблем:** ${data.description}
- **Институция:** **${data.institution}**
- **Последен статус:** "${data.status.description}" от ${formattedDate}`;
                    addBotMessage(statusMessage);
                }
            } catch (e) {
                removeProcessingMessage();
                addBotMessage(`Възникна грешка при проверката: ${e.message} 😥`);
            } finally {
                conversationState = 'idle';
                toggleInput(true);
            }
        }

        function startSignalFlow(withPhoto, initialText = null) {
            tempSignalData = {};
            conversationHistory = []; // Рестартираме историята за новия сигнал
            if (withPhoto) {
                addBotMessage("Чудесно! Моля, прикачете снимка на проблема, като използвате иконата с кламер/картинка. 🖼️");
                // UX ПОДОБРЕНИЕ: Подсказка за действие
                fileInputLabel.classList.add('highlight-action');
                setTimeout(() => fileInputLabel.classList.remove('highlight-action'), 3000);
                fileInput.click(); // Директно отваряме диалога за избор на файл
            } else {
                conversationState = 'awaiting_manual_description';
                if (initialText) {
                    processTextForSignalData(initialText);
                } else {
                    addBotMessage("Разбрано, започваме сигнал без снимка. Моля, опишете проблема с няколко думи.");
                    toggleInput(true, "Опишете проблема...");
                }
            }
        }

        async function handleFileSelect(event) {
            fileInputLabel.classList.remove('highlight-action'); // Премахваме подсказката
            let originalFile = event.target.files[0];
            if (!originalFile) return;
            event.target.value = '';

            conversationState = 'processing_image';
            toggleInput(false, 'Обработка на снимка...');
            updateProcessingMessage('Обработвам снимката... 🖼️');

            const fileName = originalFile.name.toLowerCase();
            if (fileName.endsWith('.heic') || fileName.endsWith('.heif')) {
                updateProcessingMessage("Конвертирам HEIC/Live Photo... 🔄");
                try {
                    originalFile = await handleHeicConversion(originalFile);
                } catch (error) {
                    removeProcessingMessage();
                    addBotMessage(`❌ Грешка при конвертиране на HEIC: ${error.message}`);
                    toggleInput(true); conversationState = 'idle'; return;
                }
            }

            tempSignalData = { originalFile };
            const imageBase64 = await toBase64(originalFile);
            const mediaContainer = addUserMessage(imageBase64, true);
            tempSignalData.mediaContainer = mediaContainer;

            processLocationAndContinue();
        }

        async function processLocationAndContinue() {
            updateProcessingMessage("🔍 Търся GPS данни в снимката...");
            const location = await getLocation(tempSignalData.originalFile);

            if (location.address) {
                tempSignalData.latitude = location.latitude;
                tempSignalData.longitude = location.longitude;
                tempSignalData.address = location.address;

                await animateMapInBubble(tempSignalData.mediaContainer, location.latitude, location.longitude);

                removeProcessingMessage();
                addBotMessage(`📍 Открих адрес от снимката: **${location.address}**`);
                processDescriptionAndContinue();
            } else {
                removeProcessingMessage();
                askForLocationWithButton();
            }
        }

        async function processDescriptionAndContinue() {
            updateProcessingMessage("🤖 Анализирам проблема от снимката...");
            try {
                const compressedBase64 = await compressImage(tempSignalData.originalFile);
                const description = await getDescriptionFromImage(compressedBase64);

                if (description.includes("Не е установена") || description.includes("Неясна снимка")) {
                    removeProcessingMessage();
                    addBotMessage(`🤔 ${description}. Моля, опишете проблема с няколко думи.`);
                    conversationState = 'awaiting_manual_description';
                    toggleInput(true, 'Опишете проблема...');
                    return;
                }
                tempSignalData.description = description;
                removeProcessingMessage();
                addBotMessage(`Разпознат проблем: "${description}"`);
                processInstitutionAndContinue();
            } catch (error) {
                removeProcessingMessage();
                addBotMessage(`❌ Грешка при анализ на снимка: ${error.message}`);
                conversationState = 'idle';
                toggleInput(true);
            }
        }

        async function processInstitutionAndContinue() {
            updateProcessingMessage("🏛️ Определям отговорна институция...");
            try {
                tempSignalData.institution = await getInstitution(tempSignalData.description);
                removeProcessingMessage();
                addBotMessage(`Сигналът ще бъде насочен към: **${tempSignalData.institution}**`);
            } catch (error) {
                removeProcessingMessage();
                addBotMessage(`❌ Грешка при определяне на институция: ${error.message}`);
                tempSignalData.institution = "Община Варна";
            }

            askForEmail(); // UX: Директно питаме за имейл
        }

        async function processTextForSignalData(text) {
            toggleInput(false);
            updateProcessingMessage("Анализирам информацията... 📝");

            try {
                const extractedData = await extractSignalDataFromText(text);
                if (extractedData.description) tempSignalData.description = extractedData.description;
                if (extractedData.address) tempSignalData.address = extractedData.address;
                removeProcessingMessage();

                if (!tempSignalData.description) {
                    conversationState = 'awaiting_manual_description';
                    addBotMessage("Добре, но какво е описанието на проблема?");
                    toggleInput(true, "Опишете проблема...");
                } else if (!tempSignalData.address) {
                    conversationState = 'awaiting_address';
                    askForLocationWithButton();
                } else {
                    processInstitutionAndContinue();
                }
            } catch (error) {
                removeProcessingMessage();
                addBotMessage(`Грешка при анализа на текста: ${error.message}`);
                toggleInput(true);
            }
        }

        function askForLocationWithButton() {
            const message = `Приех описанието. Сега ми е нужен адрес. Моля, въведете го, или ако сте на мястото, натиснете бутона.
<br><button id="detect-location-btn" class="location-button">📍 Засечи моята локация</button>`;
            addBotMessage(message, true);
            conversationState = 'awaiting_address';
            toggleInput(true, 'Въведете адрес...');
        }

        // UX ПОДОБРЕНИЕ: Централизиран handler за бутони
        async function handleChatButtonClick(event) {
            const target = event.target;

            // Бързи отговори
            if (target.matches('.quick-reply-btn')) {
                const action = target.dataset.action;
                target.parentElement.remove(); // Премахваме бутоните след избор
                addUserMessage(target.textContent); // Показваме избора на потребителя

                if (action === 'start_signal_photo') {
                    startSignalFlow(true);
                } else if (action === 'start_signal_no_photo') {
                    startSignalFlow(false);
                } else if (action === 'check_status') {
                    handleSignalCheck(null);
                }
                return;
            }

            // Други бутони
            if (target.id === 'detect-location-btn') handleLocationButtonClick(target);
            else if (target.id === 'skip-email-btn') handleSkipEmailClick(target);
            else if (target.id === 'confirm-btn') {
                target.closest('.button-container').innerHTML = 'Потвърдено.';
                addUserMessage("Потвърди");
                finalSubmit();
            } else if (target.id === 'cancel-btn') {
                target.closest('.button-container').innerHTML = 'Отменено.';
                addUserMessage("Отмени");
                addBotMessage("Разбрано. Сигналът е отменен. Може да започнете отначало, ако желаете.");
                conversationState = 'idle';
                toggleInput(true);
            } else if (target.id === 'edit-desc-btn' || target.id === 'edit-addr-btn') {
                const isDesc = target.id === 'edit-desc-btn';
                target.closest('.button-container').innerHTML = `Добре, променям ${isDesc ? 'описанието' : 'адреса'}.`;
                if (isDesc) {
                    conversationState = 'awaiting_manual_description';
                    addBotMessage("Моля, напишете новото описание на проблема.");
                    toggleInput(true, "Въведете ново описание...");
                } else {
                    conversationState = 'awaiting_address';
                    askForLocationWithButton();
                }
            }
        }

        function handleSkipEmailClick(button) {
            button.parentElement.innerHTML = 'Имейлът е пропуснат.';
            addUserMessage("Пропусни");
            tempSignalData.email = 'пропусни';
            askForFinalConfirmation();
        }

        async function handleLocationButtonClick(button) {
            button.textContent = 'Засичане...';
            button.disabled = true;
            toggleInput(false);

            const navLocation = await getNavigatorLocation();
            if (navLocation) {
                const address = await getAddressFromOpenCage(navLocation.latitude, navLocation.longitude);
                tempSignalData.latitude = navLocation.latitude;
                tempSignalData.longitude = navLocation.longitude;
                tempSignalData.address = address;
                addUserMessage(`📍 Използвам настоящата локация: ${address}`);

                if (tempSignalData.originalFile && !tempSignalData.description) {
                    processDescriptionAndContinue();
                } else {
                    processInstitutionAndContinue();
                }
            } else {
                addBotMessage("Неуспешно засичане на локация. Моля, разрешете достъп и опитайте пак, или въведете адреса ръчно.");
                button.textContent = '📍 Опитай пак';
                button.disabled = false;
                toggleInput(true, 'Въведете адрес...');
            }
        }

        // UX ПОДОБРЕНИЕ: Нова стъпка, която пита за имейл
        function askForEmail() {
            const message = `Почти сме готови! Ако желаете да получавате известия за статуса на сигнала, моля въведете имейл адрес.
<div class="button-container"><button id="skip-email-btn" class="location-button skip-button">Пропусни</button></div>`;
            addBotMessage(message, true);
            conversationState = 'awaiting_email';
            toggleInput(true, 'Въведете имейл...');
        }

        // UX ПОДОБРЕНИЕ: Обединена функция за финално потвърждение
        function askForFinalConfirmation() {
            let summary = `**Преглед на сигнала:**
- **Проблем:** ${tempSignalData.description}
- **Адрес:** ${tempSignalData.address}
- **Институция:** **${tempSignalData.institution}**`;

            if (tempSignalData.email && !['пропусни', 'не'].includes(tempSignalData.email)) {
                summary += `\n- **Имейл за връзка:** ${tempSignalData.email}`;
            } else {
                summary += `\n- **Имейл за връзка:** Не е предоставен`;
            }
            summary += "\n\nВсичко точно ли е? Моля, потвърдете, за да изпратим сигнала.";

            const buttonsHTML = `
    <div class="button-container">
        <button id="confirm-btn" class="location-button confirm-button">✅ Потвърди и изпрати</button>
        <button id="edit-desc-btn" class="location-button edit-button">✏️ Промени описание</button>
        <button id="edit-addr-btn" class="location-button edit-button">📍 Промени адрес</button>
        <button id="cancel-btn" class="location-button cancel-button">❌ Отмени</button>
    </div>`;

            addBotMessage(summary + buttonsHTML, true);
            conversationState = 'awaiting_confirmation';
            toggleInput(false, 'Моля, използвайте бутоните...');
        }


        async function finalSubmit() {
            conversationState = 'processing_final';
            toggleInput(false, 'Изпращане на сигнала...');

            await playNewSubmissionAnimation(tempSignalData);

            try {
                const trackCode = 'SV-' + Math.random().toString(36).substring(2, 8).toUpperCase();
                tempSignalData.trackCode = trackCode;

                if (tempSignalData.originalFile) {
                    const imageUrl = await uploadImageToSupabase(tempSignalData.originalFile, trackCode);
                    tempSignalData.imageUrl = imageUrl;
                }

                await submitSignalToSupabase(tempSignalData);
                addBotMessage(`✅ Готово! Вашият сигнал е регистриран с код за проследяване: **${trackCode}**. Благодарим Ви за активната гражданска позиция! 🚀`);

            } catch (error) {
                addBotMessage(`❌ Ох, нещо се обърка при финализиране на сигнала: ${error.message}. Моля, опитайте отново.`);
            } finally {
                conversationState = 'idle';
                toggleInput(true);
            }
        }

        async function playNewSubmissionAnimation(data) {
            return new Promise(async (resolve) => {
                const photoSrc = data.originalFile ? URL.createObjectURL(data.originalFile) : '';
                const hasLocation = data.latitude && data.longitude;

                const animationHTML = `
            <div class="card-flipper">
                <div class="card-inner">
                    <div class="card-face card-face-front">
                        <p class="card-description">${data.description}</p>
                        <div class="card-media-container">
                            ${photoSrc ? `<img src="${photoSrc}" class="card-photo" alt="Снимка на проблема">` : ''}
                            <div class="card-map"></div>
                        </div>
                    </div>
                    <div class="card-face card-face-back">
                        <img src="inst.png" class="card-institution-icon" onerror="this.style.display='none'">
                        <p class="card-institution-name">${data.institution}</p>
                    </div>
                </div>
            </div>
        `;

                const overlay = document.createElement('div');
                overlay.className = 'signal-card-overlay';
                overlay.innerHTML = animationHTML;
                document.body.appendChild(overlay);

                const cardInner = overlay.querySelector('.card-inner');
                const photoEl = overlay.querySelector('.card-photo');
                const mapEl = overlay.querySelector('.card-map');
                const delay = ms => new Promise(res => setTimeout(res, ms));

                await delay(50);
                overlay.classList.add('visible');
                await delay(300);

                if (hasLocation) {
                    if (photoEl) photoEl.classList.add('fade-out');
                    mapEl.classList.add('fade-in');
                    const map = L.map(mapEl, { zoomControl: false, scrollWheelZoom: false, dragging: false, attributionControl: false }).setView([data.latitude, data.longitude], 13);
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
                    await delay(100);
                    map.invalidateSize();
                    map.flyTo([data.latitude, data.longitude], 17, { duration: 2 });
                    await delay(1600);
                    L.marker([data.latitude, data.longitude]).addTo(map);
                    await delay(1400);
                } else {
                    await delay(3000);
                }

                cardInner.classList.add('is-flipped');
                await delay(2000);
                overlay.classList.remove('visible');
                await delay(500);
                overlay.remove();
                resolve();
            });
        }

        async function animateMapInBubble(mediaContainer, lat, lng) {
            return new Promise(resolve => {
                const photoElement = mediaContainer.querySelector('.uploaded-photo');
                if (!photoElement) { resolve(); return; }

                const mapDiv = document.createElement('div');
                mapDiv.className = 'map-inline';
                mediaContainer.appendChild(mapDiv);

                const map = L.map(mapDiv, { zoomControl: false, scrollWheelZoom: false, dragging: false, attributionControl: false }).setView([lat, lng], 13);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

                photoElement.classList.add('fade-out');
                mapDiv.classList.add('fade-in');

                setTimeout(() => {
                    map.invalidateSize();
                    map.flyTo([lat, lng], 17, { duration: 2 });
                }, 100);

                setTimeout(() => { L.marker([lat, lng]).addTo(map); }, 1600);

                setTimeout(() => {
                    mapDiv.classList.remove('fade-in');
                    mapDiv.classList.add('fade-out');
                    photoElement.classList.remove('fade-out');

                    setTimeout(() => {
                        mediaContainer.removeChild(mapDiv);
                        resolve();
                    }, 500);
                }, 4000);
            });
        }

        async function uploadImageToSupabase(file, trackCode) {
            const filePath = `photo_${trackCode}_${file.name}`;
            const { data: uploadData, error: uploadError } = await getSupabaseClientOrAlert().storage.from('signal-photos').upload(filePath, file);
            if (uploadError) throw new Error(`Грешка при качване на снимка: ${uploadError.message}`);
            const { data: urlData } = getSupabaseClientOrAlert().storage.from('signal-photos').getPublicUrl(uploadData.path);
            return urlData.publicUrl;
        }

        async function submitSignalToSupabase(data) {
            let citizenId = null;
            if (data.email && !['пропусни', 'не'].includes(data.email)) {
                const { data: existingCitizen } = await getSupabaseClientOrAlert().from('citizens').select('citizen_id, total_signals').eq('email', data.email).single();
                if (existingCitizen) {
                    await getSupabaseClientOrAlert().from('citizens').update({ total_signals: existingCitizen.total_signals + 1 }).eq('citizen_id', existingCitizen.citizen_id);
                    citizenId = existingCitizen.citizen_id;
                } else {
                    const { data: newCitizen, error: createError } = await getSupabaseClientOrAlert().from('citizens').insert({ email: data.email, total_signals: 1, registration_date: getFormattedDateTime() }).select('citizen_id').single();
                    if (createError) throw createError;
                    citizenId = newCitizen.citizen_id;
                }
            } else {
                const { data: anonCitizen, error: anonError } = await getSupabaseClientOrAlert().from('citizens').insert({}).select('citizen_id').single();
                if (anonError) throw anonError;
                citizenId = anonCitizen.citizen_id;
            }

            const { data: statusData, error: statusError } = await getSupabaseClientOrAlert().from('status').insert({
                description: "Получен сигнал",
                date_changed: getFormattedDateTime(),
                tracking_code: data.trackCode,
                status_type_id: '98e5cc79-e763-4e41-b1c2-b0303aa8f759'
            }).select('status_id').single();
            if (statusError) throw statusError;

            const { error: signalError } = await getSupabaseClientOrAlert().from('signal').insert({
                description: data.description,
                adress: data.address,
                image_url: data.imageUrl || null,
                date_created: getFormattedDateTime(),
                tracking_code: data.trackCode,
                citizen_id: citizenId,
                status_id: statusData.status_id,
                institution: data.institution,
                latitude: data.latitude || null,
                longitude: data.longitude || null
            });
            if (signalError) throw signalError;
        }

        async function handleHeicConversion(heicFile) {
            if (typeof libheif === 'undefined') {
                throw new Error("Библиотеката за HEIC конвертиране не е заредена. Моля, проверете интернет връзката си и презаредете страницата.");
            }
            const arrayBuffer = await heicFile.arrayBuffer();
            const decoder = new libheif.HeifDecoder();
            const images = decoder.decode(arrayBuffer);
            if (!images || images.length === 0) throw new Error('Файлът не съдържа изображения.');

            const firstImage = images[0];
            const width = firstImage.get_width(); const height = firstImage.get_height();

            const imageData = await new Promise((resolve, reject) => {
                firstImage.get_image_data(width, height, (data) => data ? resolve(data) : reject(new Error('Неуспешно извличане на кадър.')));
            });

            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            canvas.getContext('2d').putImageData(imageData, 0, 0);

            return new Promise(resolve => canvas.toBlob(blob => {
                resolve(new File([blob], "converted.jpeg", { type: "image/jpeg" }));
            }, 'image/jpeg', 0.9));
        }

        function getFormattedDateTime() { return new Date().toISOString().slice(0, 19).replace('T', ' '); }

        async function getLocation(file) {
            const exif = await getExifLocation(file);
            if (exif && exif.latitude && exif.longitude) {
                const address = await getAddressFromOpenCage(exif.latitude, exif.longitude);
                return { ...exif, address };
            }
            return { error: "Няма EXIF данни." };
        }
        function getExifLocation(file) { return new Promise(r => EXIF.getData(file, function () { const la = EXIF.getTag(this, "GPSLatitude"), lo = EXIF.getTag(this, "GPSLongitude"), laR = EXIF.getTag(this, "GPSLatitudeRef"), loR = EXIF.getTag(this, "GPSLongitudeRef"); const dmsToDd = (d, dir) => { if (!d) return null; let dd = d[0] + d[1] / 60 + d[2] / 3600; if (dir === "S" || dir === "W") dd *= -1; return dd; }; if (la && lo) r({ latitude: dmsToDd(la, laR), longitude: dmsToDd(lo, loR) }); else r(null) })); }
        function getNavigatorLocation() { return new Promise(r => !navigator.geolocation ? r(null) : navigator.geolocation.getCurrentPosition(p => r({ latitude: p.coords.latitude, longitude: p.coords.longitude }), () => r(null), { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 })) }
        async function getAddressFromOpenCage(lat, lng) {
            const apiUrl = `/api/get-address?lat=${lat}&lng=${lng}`;
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                if (data && data.results && data.results.length > 0 && data.results[0].formatted) {
                    return data.results[0].formatted;
                }
                return `Адрес не е намерен за координати.`;
            } catch (error) { console.error('OpenCage Error:', error); return "Грешка при зареждане на адрес."; }
        }
        const toBase64 = file => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
        function compressImage(file, maxWidth = 1024, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = error => reject(error);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = error => reject(error);
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let { width, height } = img;
                        if (width > maxWidth) { height = (maxWidth / width) * height; width = maxWidth; }
                        canvas.width = width; canvas.height = height;
                        canvas.getContext('2d').drawImage(img, 0, 0, width, height);
                        resolve(canvas.toDataURL('image/jpeg', quality));
                    };
                };
            });
        }

        // ЗАМЯНА: Анализ на изображение чрез бекенда
        async function getDescriptionFromImage(base64Image) {
            const headers = { "Content-Type": "application/json" };
            const payload = { base64Image, systemPrompt: OPENAI_VISION_SYSTEM_PROMPT };
            try {
                const response = await fetch("/api/analyze-image", { method: "POST", headers, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error("Грешка при анализ на изображение");
                const data = await response.json();
                if (data && data.description) return data.description;
                return "Неясна снимка, моля опишете проблема";
            } catch (error) {
                return `Грешка при анализ: ${error.message}`;
            }
        }
        // ЗАМЯНА: Определяне на институция чрез бекенда
        async function getInstitution(description) {
            const headers = { "Content-Type": "application/json" };
            const payload = { description, systemPrompt: OPENAI_INSTITUTION_PROMPT };
            try {
                const response = await fetch("/api/get-institution", { method: "POST", headers, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error("Грешка при определяне на институция");
                const data = await response.json();
                if (data && data.institution) return data.institution.trim();
                return "Община Варна";
            } catch (error) {
                return "Община Варна";
            }
        }
        // ЗАМЯНА: Intent extraction чрез бекенда (трябва да има такъв endpoint)
        async function getIntentFromText(text) {
            const headers = { "Content-Type": "application/json" };
            const payload = { text, systemPrompt: OPENAI_INTENT_PROMPT };
            try {
                const response = await fetch("/api/get-intent", { method: "POST", headers, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error("Грешка при анализ на намерение");
                const data = await response.json();
                return data;
            } catch (error) {
                return { intent: "general_chat", tracking_code: null };
            }
        }
        // ЗАМЯНА: Extraction на описание и адрес чрез бекенда (трябва да има такъв endpoint)
        async function extractSignalDataFromText(text) {
            const headers = { "Content-Type": "application/json" };
            const payload = { text, systemPrompt: OPENAI_EXTRACTION_PROMPT };
            try {
                const response = await fetch("/api/get-extract", { method: "POST", headers, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error("Грешка при извличане на данни");
                const data = await response.json();
                return data;
            } catch (error) {
                return { description: text, address: null };
            }
        }
        function isValidEmail(email) {
            const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
            return re.test(String(email).toLowerCase());
        }
        function setupSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'bg-BG';
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;
                recognition.onstart = () => { micBtn.classList.add('listening'); };
                recognition.onend = () => { micBtn.classList.remove('listening'); };
                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    chatInput.value = transcript;
                    handleTextInput();
                };
                recognition.onerror = (event) => { addBotMessage(`Грешка при гласовото разпознаване: ${event.error}`); };
            } else {
                micBtn.style.display = 'none';
            }
        }
        function toggleSpeechRecognition() {
            if (micBtn.classList.contains('listening')) {
                recognition.stop();
            } else {
                recognition.start();
            }
        }

        // --- Supabase secure initialization ---
        function getSupabaseClientOrAlert() {
            if (!window.supabaseClient) {
                alert('Supabase клиентът не е инициализиран! Провери ключовете.');
                throw new Error('Supabase клиентът не е инициализиран!');
            }
            return window.supabaseClient;
        }
        async function loadSupabaseKeys() {
            try {
                const response = await fetch('/api/supabase-keys');
                if (!response.ok) throw new Error('Неуспешно зареждане на Supabase ключове');
                const data = await response.json();
                if (!data.url || !data.anonKey) throw new Error('Липсват Supabase ключове или URL!');
                window.supabaseClient = supabase.createClient(data.url, data.anonKey);
            } catch (error) {
                alert('Грешка при зареждане на Supabase ключове: ' + error.message);
                console.error('Грешка при зареждане на Supabase ключове:', error);
            }
        }
        document.addEventListener('DOMContentLoaded', function () {
            loadSupabaseKeys();
        });

    </script>
</body>

</html>